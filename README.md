[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18397329&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the systematic application of engineering principles to the design, development, testing, deployment, and maintenance of software, which involves Writing code for computers, building apps, games and websites and solving real world problems using technology.
Importance:
Increasing software Productivity & Quality – Ensuring efficient software development while maintaining high standards.
Effective Scheduling & Planning – Organizing projects to meet deadlines efficiently.
Reducing Development Costs – Optimizing resources and minimizing expenses.
Meeting Customer Needs – Ensuring software aligns with user requirements.
Enhancing Software Processes – Improving methodologies and best practices.
Advancing Engineering Practices – Continuously refining software engineering standards.
Systematic & Efficient Support for Engineers – Providing structured workflows for better performance.

Identify and describe at least three key milestones in the evolution of software engineering.
1. The Birth of Software Engineering (1968)
The term "software engineering" was first introduced at the 1968 NATO Software Engineering Conference in response to the software crisis—where software projects were failing due to poor planning, high costs, and inefficiencies.
This milestone emphasized the need for structured approaches, formal methods, and disciplined processes in software development.
2. The Emergence of Structured Programming (1970s)
In the 1970s, structured programming became widely accepted, thanks to contributions from figures like Edsger Dijkstra.
It introduced principles such as modular design, top-down development, and control structures (if-else, loops, functions), which improved code readability and maintainability.
Programming languages like C and Pascal were developed, promoting structured programming practices.
3. The Rise of Agile Methodologies (2001)
In response to the limitations of traditional Waterfall development, the Agile Manifesto was published in 2001 by a group of software developers.
Agile introduced principles like iterative development, customer collaboration, and flexibility, making software development more adaptable to changing requirements.
Frameworks like Scrum and Kanban became popular, leading to modern software development practices.


List and briefly explain the phases of the Software Development Life Cycle.
1. Planning and Requirements Analysis-  Defines the project scope, objectives, and feasibility, estimates costs, risks and is done by senior members of the team.
2. Defining Requirements -Done through SRS- Software Requirement Specification document which consists of all the product requirements to be designed and developed during the project life cycle. 
3. Designing the Software - Based on the requirements specified in SRS, usually more than one design approach for the product architecture is proposed and documented in a DDS - Design Document Specification.This DDS is reviewed by all the stakeholders and based on various parameters as risk assessment, design modularity, budget and time constraints, the best design approach is selected for the software.
4. Building or Developing the Software- In this stage of SDLC the actual development starts and the product is built. The programming code is generated as per DDS during this stage. Developers have to follow the coding guidelines defined by their organization and programming tools like compilers, interpreters, debuggers etc are used to generate and implement the code
5. Testing the Software -this stage refers to the testing only that stage of the software where defects are reported, tracked, fixed and retested, until the software reaches the quality standards defined in the SRS.
6. Deployment and Maintenance- Once the software is tested and no bugs or errors are reported then it is deployed. Then based on the feedback, the software may be released as it is or with suggested enhancements in the target segment. Afterwards, the software is deployed then its maintenance starts.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Similarities Between Agile and Waterfall: 
1. They have similar goals, which are to produce high-quality software applications and make clients happy and content.
2. They perform the same activities, which include collecting requirements, designing, developing, testing, and deploying.
3. The foundation of a project involves planning, bringing the project to life, and monitoring the project’s progress in the two methodologies.
Differences between Agile and Waterfall:
1. Analysis of feasibility
Waterfall methodology: This process takes quite a lot of time to prevent reworking in the following phases of the project. It involves analyzing cost and benefit to determine if the plan is financially, technically, and operationally achievable. At times it may lead to a business case.
Agile project management: This takes as little time as possible. You can contact clients in good time in the first stages of the project and settle the project requirements and task details.

2. Planning process
Waterfall project management: Planning in detail is very crucial and is done just once. It allows them to achieve the set goals of the project without making any alterations to the requirements or scope of the project. You can track the formulated plan at the beginning of the project in the entire project progress after it’s set the baseline. You can make no change.
Agile methodology: Not done in advance but when the team is prepared to take on a particular set of the requirements and begin to outline the development. In this case, planning is an ongoing process since the team works on an active sprint. Changing the plan is allowed, but you cannot add new requirements to an active sprint.

3. Monitoring and tracking processes
Waterfall methodology: You can monitor the project’s progress. Frequent status reviews are carried out to analyze the development. Afterward, the status reports will be sent to the management team and the project sponsors. The project managers also make weekly/monthly reports of status and share them with the stakeholders.
Agile methodology: It is different as the progress gets measured in each sprint. The project team does this, then the sprint reports are handed over to the stakeholders. Another way of tracking project progress is through the demo of the built functionality.

4. Roles delegation
Waterfall methodology: Project team members get assigned particular tasks, and one can work on only their delegated role. It is not up for any change whatsoever in the project life cycle. For example, a developer-only takes care of development tasks and cannot handle any other work.
Agile project management: The teams are self-organizing and can switch roles among themselves. Or they can work in cycles, for example, a developer can assist a tester in the testing process. There is only a case of scrum master exception in which you can swap with the project manager.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
1. Software Developer
Role: Responsible for designing, coding, testing, and maintaining software applications.
Key Responsibilities:
Write clean, efficient, and maintainable code.
Follow software design principles and architecture guidelines.
Debug and fix software issues.
Collaborate with other developers, designers, and stakeholders.
Use version control tools like Git for code management.
Implement security measures and optimize application performance.

2. Quality Assurance (QA) Engineer
Role: Ensures the software is functional, reliable, and bug-free before release.
Key Responsibilities:
Develop and execute test plans, test cases, and test scripts.
Conduct various types of testing (unit, integration, system, regression, performance, security).
Identify, document, and report bugs or defects in the software.
Work closely with developers to resolve issues and improve software quality.
Automate testing processes where applicable.
Ensure the software meets industry standards and customer expectations.

3. Project Manager
Role: Oversees the software development process, ensuring the project is completed on time, within scope, and within budget.
Key Responsibilities:
Define project goals, scope, and deliverables.
Develop project timelines, resource allocation, and risk management strategies.
Facilitate communication between team members and stakeholders.
Monitor progress, track deadlines, and adjust plans as needed.
Manage team performance and resolve conflicts.
Ensure documentation, reporting, and compliance with best practices.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
1. Integrated Development Environments (IDEs)
An IDE is a software application that provides developers with a comprehensive environment to write, edit, debug, and test code efficiently.
Importance of IDEs:
Code Efficiency & Productivity: Provides features like syntax highlighting, auto-completion, and code refactoring tools to streamline development.
Debugging Tools: Built-in debuggers help identify and fix errors quickly.
Code Compilation & Execution: Most IDEs support multiple programming languages and allow direct execution without switching environments.
Project Management: Helps organize files, libraries, and dependencies in large projects.
Integration with Tools & Frameworks: Supports version control, testing frameworks, and database management.
Examples of IDEs:
Visual Studio Code (VS Code), Turbo C++, IntelliJ IDEA,PyCharm,Eclipse.
2. Version Control Systems (VCS)
A VCS is a system that tracks changes in source code, allowing multiple developers to collaborate efficiently.
Importance of VCS:
Code Collaboration: Multiple developers can work on the same project without conflicts.
Change Tracking: Keeps a history of changes, making it easy to revert to previous versions if necessary.
Branching & Merging: Developers can work on different features in separate branches and merge them when ready.
Backup & Recovery: Protects against accidental loss of code.
Facilitates CI/CD: Works with automation tools for continuous integration and deployment.
Examples of VCS:
Git,GitHub,GitLab, Bitbucket.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
1. Keeping Up with Rapidly Changing Technologies
Challenge: New programming languages, frameworks, and tools emerge frequently, making it hard to stay updated.
Solution:
Follow tech blogs, podcasts, and online communities.
Take online courses (Coursera, Udemy, etc.).
Engage in open-source projects and hands-on coding exercises.
2. Debugging and Fixing Complex Bugs
Challenge: Identifying and fixing bugs in large codebases can be time-consuming.
Solution:
Use debugging tools available in IDEs (e.g., breakpoints, stack traces).
Implement logging mechanisms for better error tracking.
Break down problems and isolate code sections for easier debugging.
3. Managing Workload and Meeting Deadlines
Challenge: Balancing multiple projects and deadlines can lead to burnout.
Solution:
Use project management tools (Trello, Jira, Asana) to organize tasks.
Prioritize tasks using the Eisenhower Matrix (urgent vs. important).
Practice time management techniques like the Pomodoro technique.
4. Handling Code Reviews and Team Collaboration
Challenge: Receiving and giving feedback in code reviews can sometimes be challenging.
Solution:
Keep an open mind and accept constructive criticism positively.
Follow coding standards and best practices to improve code quality.
Use collaboration tools like GitHub, GitLab, and Bitbucket.
5. Writing Scalable and Maintainable Code
Challenge: Poorly written code can lead to performance issues and difficulties in future updates.
Solution:
Follow coding best practices (SOLID principles, DRY, and KISS).
Write clear and well-documented code.
Implement automated testing to prevent future issues.
6. Security Vulnerabilities
Challenge: Software applications are prone to security risks such as SQL injection, XSS, and data breaches.
Solution:
Use secure coding practices and follow OWASP guidelines.
Regularly update dependencies and conduct security audits.
Implement authentication and encryption for data protection.
7. Managing Technical Debt
Challenge: Accumulating quick fixes and inefficient code can slow down development.
Solution:
Allocate time for refactoring and improving existing code.
Maintain proper documentation to avoid confusion in future changes.
Use code reviews and best practices to minimize technical debt early.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
1. Unit Testing
Unit testing involves testing individual components or functions of the software in isolation to ensure they work as expected. Done by developers.
It Identifies bugs early, improves code quality, and ensures that each module performs its intended function.
Tools Used: JUnit (Java), NUnit (.NET), PyTest (Python), Jest (JavaScript).
2. Integration Testing
Integration testing checks how different modules or components work together as a group.
It Ensures that data flows correctly between interconnected modules and detects interface-related issues.
Done by Developers or QA engineers.
Tools Used: Postman (API testing), JUnit, TestNG, Selenium.
3. System Testing
A complete test of the entire software application to verify that it meets functional and non-functional requirements.
It Ensures that the software behaves correctly in real-world scenarios, covering performance, security, usability, and compliance.
Done by QA engineers or independent testers.
Tools Used: Selenium, JMeter (performance testing), LoadRunner.
4. Acceptance Testing (User Acceptance Testing - UAT)
The final phase of testing where real users test the software to ensure it meets their needs before release.
It Validates that the system works as intended from the end user’s perspective and meets business goals.
Done by End users or clients.
Tools Used: Manual testing, Cucumber (for behavior-driven testing).
Why These Testing Types Matter?
1. Improves software quality by identifying bugs before release.
2. Reduces development costs by catching defects early.
3. Enhances user satisfaction by ensuring a smooth experience.
4. Ensures compliance with industry standards.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the practice of designing and refining inputs (prompts) to effectively interact with AI models, such as ChatGPT, to achieve desired responses. It involves structuring queries, providing context, and using specific instructions to guide AI behavior.
Importance of Prompt Engineering in AI Interaction
1. Enhances Response Accuracy
Well-structured prompts ensure the AI understands the request, reducing vague or irrelevant answers.
2. Improves AI Efficiency
Well-crafted prompts reduce the need for multiple follow-ups by getting the correct response on the first attempt.
3. Prompt engineering allows users to fine-tune responses based on tone, format, and detail level.
4. Facilitates Better AI-Assisted Decision Making
AI models can assist with coding, research, content generation, and troubleshooting when given clear prompts.
5. Reduces Bias and Misinterpretation
Carefully crafted prompts minimize ambiguous or biased responses, leading to fairer AI-generated content.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Vague prompt:  "Tell me about heart disease."
Improved Prompt: "Explain the risk factors, symptoms, and treatment options for coronary artery disease in adults over 50."
Why the Improved Prompt is More Effective
1. More Specific – Instead of asking about "heart disease" in general, it focuses on coronary artery disease, a common type.
2. Targeted Audience – It specifies adults over 50, allowing for age-appropriate risk factors and treatments.
3. Defined Scope – It requests details on risk factors, symptoms, and treatment options, ensuring a well-structured response.
